#+TITLE: Spherical Series
#+DATE: <2017-11-23 Do> Rev. Time-stamp: <2019-11-03 00:17:23 jbatke>
#+AUTHOR: Johann-Markus Batke
#+EMAIL: JBatke@technik-emden.de
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 25.2.2 (Org mode 9.1.3)
#+setupfile: octavetemplates.org
#+setupfile: booast.setup
#+exclude_tags: internal
#+property: header-args:org               :eval export :exports results
#+PROPERTY: header-args:octave :noweb yes :eval export

* General Information
This is all about Higher Order Ambisonics.

We need to implement some math.
* Spherical Mathematics
** Fourier Bessel Series
Spherical Series provides means to calculate the "Fourier Bessel
Series".  The form of this series is
\begin{equation}
  \label{eq:fbs}
  P(r, \theta, \phi, k) = \sum_{n = 0}^{\infty} \sum_{m = -n}^{n} 
  \left\{\begin{array}{ll}
  A_{n}^{m}(k) & j_n(kr) \\
  B_{n}^{m}(k) & h_n(kr) \\
  \end{array}\right\}
  Y_{n}^{m}(\theta, \phi).
\end{equation}

In particular, we have
- $A_{n}^{m}(k)$ coefficients describing a soundfield outside 
- $B_{n}^{m}(k)$ coefficients describing a soundfield inside
- $j_n(kr)$ the spherical bessel function
- $h_n(kr)$ the spherical hankel function
- $Y_{n}^{m}(\theta, \phi)$ spherical harmonics
- $k = \omega/\mathrm c$ wavenumber
- $\mathrm c$ speed of sound

** HOA Series
The product $j_n(kr) \, Y_{n}^{m}(\theta, \phi)$ may combined to a basefunction $R_n^m(r, \theta, \phi, k)$ and $h_n(kr) \,
Y_{n}^{m}(\theta, \phi)$ is combined to basefunction $S_n^m(r, \theta, \phi, k)$
yielding 
\begin{equation}
  \label{eq:1r}
  P(r, \theta, \phi, k) = \sum_{n = 0}^{\infty} \sum_{m = -n}^{n} 
  \left\{\begin{array}{ll}
      A_{n}^{m}(k) & R_n^m(r, \theta, \phi, k)\\
      B_{n}^{m}(k) & S_n^m(r, \theta, \phi, k)\\
  \end{array}\right. .
\end{equation}

** Spherical Fourier Transform
Combination of $A_{n}^{m}(k)$ and $j_n(kr)$ results in 
\begin{equation}
  \label{eq:sfs}
  P(r, \theta, \phi, k) = \sum_{n = 0}^{\infty} \sum_{m = -n}^{n} 
  \left\{\begin{array}{ll}
  C_{n}^{m}(k,r) \\
  D_{n}^{m}(k,r) \\
  \end{array}\right\}
  Y_{n}^{m}(\theta, \phi).
\end{equation}

* Spherical Functions
** sphericalbesselj
file:sphericalbesselj.m: calculates spherical bessel function at order N


*** Octave definition                                              :internal:

#+BEGIN_SRC octave :tangle sphericalbesselj.m
<<sphericalbesselj doc[:results ascii :post octave comment(s=*this*)]()>>
<<copyright>>

function J_sph_CF = sphericalbesselj(N_order, x_CF)
  
  C = size(x_CF, 1);
  F = size(x_CF, 2);
  L = C*F;
  x_L = reshape(x_CF, 1, L);
  J_sph_L = zeros(L, 1);
  
  % finde Nullen im Argument
  idx_zero = (x_L == 0);

  % Ergebnis zuweisen
  if N_order == 0
    J_sph_L(idx_zero) = 1;
  else
    J_sph_L(idx_zero) = 0;
  end

  % finde den Rest
  idx_nzero = (x_L ~= 0);

  % Ergebnis zuweisen
  J_sph_L(idx_nzero) = sqrt(pi ./ (2*x_L(idx_nzero))) .* ...
      besselj(N_order + 0.5, x_L(idx_nzero));

  % Form retten
  J_sph_CF = reshape(J_sph_L, C, F);

#+END_SRC

*** Interface test                                                 :internal:
#+BEGIN_SRC octave
N_order = 3;
r_C = linspace(1, 2, 2);
k_F = linspace(1, 2, 2);
J_sph_CF = sphericalbesselj(N_order, r_C'*k_F);
ans = size(J_sph_CF);
#+END_SRC

#+RESULTS:
| 2 | 2 |

*** Documenation                                                     :ignore:

#+name: sphericalbesselj doc
#+BEGIN_SRC org
,*** Syntax
: J_sph_CF = sphericalbesselj(N_order, x_CF);

,*** Description
spherical bessel function at order N

,*** Input Arguments
- x_CF :: C x F matrix

,*** Return Values
- J_sph_CF :: C x F matrix

,*** Examples

,*** Tips

,*** Alternatives

,*** See Also
#+END_SRC

#+call: sphericalbesselj doc[:output html]()


** sphericalbessel

file:sphericalbessel.m: wrapper for sphericalbesselj, return all orders up to N

*** Octave definition                                              :internal:

#+BEGIN_SRC octave :tangle sphericalbessel.m
<<sphericalbessel doc[:results ascii :post octave comment(s=*this*)]()>>
<<copyright>>
function J_sph_OCF = sphericalbessel(N_order, x_CF)

  if length(size(x_CF)) > 2
    error('Input argument must not have more than 2 dimensions.');
  end
  
  % Speicher
  O = (N_order+1)^2;
  C = size(x_CF, 1);
  F = size(x_CF, 2);
  J_sph_OCF = zeros(O, C, F);
  
  for n = 0:N_order
    J_CF = sphericalbesselj(n, x_CF);
    for m = -n:n
      J_sph_OCF(n^2+n+m+1, :, :) = J_CF;
    end
  end
#+END_SRC

*** Interface test                                                 :internal:

#+BEGIN_SRC octave
N_order = 3;
r_C = linspace(1, 2, 2);
k_F = linspace(1, 2, 2);
J_sph_OCF = sphericalbessel(N_order, r_C'*k_F);
ans = size(J_sph_OCF);
#+END_SRC

#+RESULTS:
| 16 | 2 | 2 |

*** Documenation                                                     :ignore:

#+name: sphericalbessel doc
#+BEGIN_SRC org
,*** Syntax
: J_sph_OCF = sphericalbessel(N_order, x_CF)

,*** Description

,*** Input Arguments

,*** Return Values

,*** Examples

,*** Tips

,*** Alternatives

,*** See Also
#+END_SRC

#+call: sphericalbessel doc[:output html]()


** sphericalnormalisation
=sphericalnormalisation= - calculates the normalization factor 
file:./sphericalnormalisation.m
*** Octave definition                                              :internal:
#+BEGIN_SRC octave :tangle sphericalnormalisation.m 
<<sphericalnormalisation doc[:results ascii :post octave comment(s=*this*)]()>>
<<copyright>>

function N_O = sphericalnormalisation(N_order, norm)
  if nargin < 2
    norm = 'norm';
  end
  N_O = zeros((N_order+1)^2, 1);

  if strcmp(norm, 'norm')
    % fully normalised
    for n = 0:N_order
	 for m = -n:n
        o = n^2+n+m+1;
        N_O(o) = sqrt((2*n + 1)/(4*pi) * ...
			 factorial(n-abs(m))/...
			 factorial(n+abs(m)));
	 end
    end
 
  elseif strcmpi(norm, 'N3D')
    % 3D after Daniel
    % fÃ¼hrt zu Energie = 4 pi
    for n = 0:N_order
	 for m = -n:n
        o = n^2+n+m+1;
        N_O(o) = sqrt((2*n + 1) * ...
			 factorial(n-abs(m))/...
			 factorial(n+abs(m)));
	 end
    end  

  elseif strcmpi(norm, 'SN3D')
    % Schmidt semi norm, see Wikipedia
    % SN3D
    for n = 0:N_order
	 for m = -n:n
        o = n^2+n+m+1;
        N_O(o) = sqrt(factorial(n-abs(m))/...
			 factorial(n+abs(m)));
	 end
    end  

  elseif strcmp(norm, 'sch1')
    % Schmidt semi norm, siehe Matlab -- mit Wurzel 2
    for n = 0:N_order
	 for m = -n:n
        o = n^2+n+m+1;
        if m ~= 0
          N_O(o) = sqrt(2*factorial(n-abs(m))/...
                        factorial(n+abs(m)));
        else
          N_O(o) = 1;
        end
	 end
    end  

  elseif strcmp(norm, 'sconv')
    % spherical convolution
    for n = 0:N_order
	 for m = -n:n
        o = n^2+n+m+1;
        N_O(o) = (2*pi) * sqrt((4*pi)/(2*n + 1));
	 end
    end  

  elseif strcmp(norm, 'planewave')
    % plane wave
    for n = 0:N_order
	 for m = -n:n
        o = n^2+n+m+1;
        N_O(o) = 4*pi*1i^n;
	 end
    end  

  else
    error('Unknown norm ''%s''', norm);
  end

 #+END_SRC

 #+RESULTS:
*** Interface test                                                 :internal:

 #+name: sphericalnormalisation test
 #+BEGIN_SRC octave 
 N_order = 1;
 S_norm = 'norm';
 sphericalnormalisation(N_order, S_norm)
 #+END_SRC

 #+RESULTS: sphericalnormalisation test
 | 0.2820947917738781 |
 | 0.3454941494713355 |
 | 0.4886025119029199 |
 | 0.3454941494713355 |

*** Documentation                                                    :ignore:

#+name: sphericalnormalisation doc
#+BEGIN_SRC org :exports results 
,*** Syntax
: N_O = sphericalnormalisation(N_order, norm)

,*** Description
Calculates the normalization factor for a given harmonic order and
normalization type.  If the type of normalization is not defined at
the output, full normalization 'norm' will be performed.

,*** Input Arguments
- N_order :: order of a spherical harmonic
- norm :: type of normalization: 
  | 'norm'                | fully normalized;                     |
  | 'N3D'                 | normalized;                           |
  | 'sch0' or 'SN3D'      | seminormalazed                        |
  | 'sch1'                | Schmidt-Semi-normalized (Matlab)      |
  | 'sconv'               | norm. over all spherical convolutions |
  | 'planewave_impinging' | norm. for plane waves                 |

,*** Return Values
  - N_O - corresponding normalization factor
#+END_SRC

#+call: sphericalnormalisation doc[:output html]()
*** Examples
*** Tips
*** Alternatives
*** See Also

** sphericallegendre

file:sphericallegendre.m: calculates spherical Legendre functions

*** Octave definition                                              :internal:
#+BEGIN_SRC octave :tangle sphericallegendre.m
<<sphericallegendre doc[:results ascii :post octave comment(s=*this*)]()>>
<<copyright>>

 function P_OA = sphericallegendre(N_order, theta_A)

   O = (N_order+1)^2;
   A = length(theta_A);  % Anzahl der theta Werte
   P_OA = zeros(O, A);   % Legendre polynom 1. art
   Q_OA = zeros(O, A);   % Legendre polynom 2. art
  
   for n = 0:N_order % order index
     % hier keine Normierung verwendet, stattdessen sphericalnormalisation
     % legendre polynomial includes the (-1)^m term
     P_QA = legendre(n, cos(theta_A));
     % size: (n+1)xA
     % P_n^m(cos(theta_A)) ist in Zeile m+1; m = 0..n
     % see: http://www.mathworks.com/help/techdoc/ref/legendre.html
     % P_n^m(x) = (-1)^m (1-x^2)^{m/2} \frac{\mathrm d^m}{\mathrm d x^m} P_n(x).
    
     % Indizes in der Koeffzi.-Pyramide links/mitte/rechts
     o_l = n^2+1;     % 1 + ACN(n, m=-n); ACN(n, m) = n*(n+1) + m;
     o_m = n^2+n+1;   % 1 + ACN(n, m=0)
     o_r = n^2+2*n+1; % 1 + ACN(n, m=+n)

     % m >= 0
     P_OA(o_m:o_r, :) = P_QA;
     if n > 0
         % m < 0
         m = -1:-1:-n;
         fac = repmat((-1).^m(:), 1, A); 
         P_OA([o_m-1:-1:o_l], :) = fac .* P_QA(2:end,:);
     end
   end
#+END_SRC

*** Interface test                                                 :internal:
 #+name: sphericallegendre test
 #+BEGIN_SRC octave :results file
   % Legendrefunktionen
   N_order = 2;
   theta_A = linspace(0, pi, 90);
   P_OA = sphericallegendre(N_order, theta_A);
   figure(1);
   plot(P_OA.'); xlabel('\theta'); ylabel('P_{n}(\theta)')
   S_file = 'img/legendre.png'; saveas(1, S_file);
   ans = S_file;
 #+END_SRC
 #+attr_org: :width 500
 #+RESULTS: sphericallegendre test
 [[file:img/legendre.png]]

*** Documenation                                                     :ignore:
#+name: sphericallegendre doc
#+BEGIN_SRC org
,*** Syntax

: P_OA = sphericallegendre(N_order, theta_A)

,*** Description

Resulting matrix of Legendre function values has the dimensions ((N_order+1)^2+1)xlength(theta_A).
For positive odd m a negative sign is used.
No normalization is used.
Regarding normalization the calculation is done for a symmetric calculation of m.

- for $m >= 0$: $P_n^m(\cos(\theta )$  [including $(-1)^m$]
- for $m < 0:$  $(-1)^m P_n^{|m|}(\cos(\theta )$

equivalent to (using legendre polynomial notation without Condon-Shortley phase):
- for $m >= 0$: $(-1)^m P_n,|m|( \cos(\theta )$
- for $m < 0$:  $P_n,|m|( \cos(\theta )$

,*** Input Arguments

- N_order :: order of the spherical harmonic
- theta_A :: vector representing the calculation range of inclination theta

,*** Return Values

- P_OA :: matrix of Legendre function values

,*** See Also
legendre 
#+END_SRC

#+call: sphericallegendre doc[:output html]()

** trg

file:trg.m: calculates something for given argument
*** Octave definition                                              :internal:
#+BEGIN_SRC octave :tangle trg.m
<<named doc[:results ascii :post octave comment(s=*this*)]()>>
<<copyright>>
 function y = trg(m, x)
   if m > 0
     y = (-1)^m * sqrt(2) * cos(m*x);
   elseif m < 0
     y = (-1) * sqrt(2) * sin(m*x);
   else % m == 0
     y = 1;
   end
#+END_SRC
*** Interface test                                                 :internal:
tbd
*** Documenation                                                     :ignore:
#+name: named doc
#+BEGIN_SRC org
,*** Syntax
: y = trg(m, x)
,*** Description

,*** Input Arguments

- x : numeric argument
- m : order

,*** Return Values

y
#+END_SRC

#+call: named doc[:output html]()

*** Examples
*** Tips
*** Alternatives
*** See Also
trh

** trh
file:trh.m: calculates something for given argument
*** Octave definition                                              :internal:
#+BEGIN_SRC octave :tangle trh.m
<<named doc[:results ascii :post octave comment(s=*this*)]()>>
<<copyright>>
 function y = trh(m, x)
   if m > 0
     y = sqrt(2) * cos(m*x);
   elseif m < 0
     y = -sqrt(2) * sin(m*x); % = sqrt(2) * sin(abs(m) * x)
   else % m == 0
     y = 1;
   end
#+END_SRC
*** Interface test                                                 :internal:
*** Documenation                                                     :ignore:
#+name: trg doc
#+BEGIN_SRC org
,*** Syntax
,*** Description

real-valued circular harmonics 2D normalised (N2D) of degree m and azimuth x

2D normalised (N2D) as defined in sec. 3.1 of
J. Daniel: 
Spatial Sound Endcoding Including Near Field Effect: Introducing Distance 
coding Filters and a Viable, New Ambisonic Format, 
AES 23rd International Conference, 2003

,*** Input Arguments
- m :: degree
- x :: azimuth

,*** Return Values
- y :: circular harmonic
#+END_SRC

#+call: trg doc[:output html]()

*** Examples
*** Tips
*** Alternatives
*** See Also
trh

** sphericalazimuth

file:sphericalazimuth.m: calculates spherical azimuth of order N for angle phi 

*** Octave definition                                              :internal:
#+BEGIN_SRC octave :tangle sphericalazimuth.m
<<named doc[:results ascii :post octave comment(s=*this*)]()>>
<<copyright>>
 function D_OB = sphericalazimuth(N_order, phi_B, S_type)
 if nargin < 3
   S_type = 'complex';
 end

 D_OB = zeros((N_order+1)^2, length(phi_B));
 switch S_type 
   case 'complex'
     for n= 0:N_order
       for m = -n:n
         o = n^2+n+m+1;
         D_OB(o,:) = exp(1i*m*phi_B);
       end
     end
   case {'real_signed', 'real'}
     for n= 0:N_order
       for m = -n:n
         o = n^2+n+m+1;
         D_OB(o,:) = trg(m, phi_B);
       end
     end
   case 'real_unsigned'
     for n= 0:N_order
       for m = -n:n
         o = n^2+n+m+1;
         D_OB(o,:) = trh(m, phi_B);
       end
     end
   otherwise
     error('Unknown spherical azimuth type %s!', S_type);
 end
#+END_SRC
*** Interface test                                                 :internal:
*** Documenation                                                     :ignore:
#+name: sphericalazimuth doc
#+BEGIN_SRC org
,*** Syntax
: D_OB = sphericalazimuth(N_order, phi_B, S_type)

,*** Description
spherical azimuth of order N for angle phi 

If less than 3 variablrs are defined at the input, calculation is done
for S_type = 'complex' case.

,*** Input Arguments
- N_order :: order of the spherical harmonic
- phi_B :: vector representing the calculation range of azimuth phi ?
- S_type :: type of the spherical harmonic: 'real', 'real_signed', 'real_unsigned'  or 'complex'

,*** Return Values
- D_OB :: matrix with o orders and B angles
#+END_SRC

#+call: sphericalazimuth doc[:output html]()

*** Examples

 #+name: sphericalazimuth test
 #+BEGIN_SRC octave :exports results :results file
   N_order = 2;
   o = 1:(N_order+1)^2;

   B = 128;
   phi_B = linspace(0, 2*pi, B);

   S_type_list{1} = 'complex';
   S_type_list{2} = 'real';

   for n = 1:length(S_type_list)
     D_OB{n} = sphericalazimuth(N_order, phi_B, S_type_list{n});

     figure(n);
     plot(phi_B, real(D_OB{n}.'));
     xlabel('\phi_B');
     ylabel('azimuth');
     title(S_type_list{n});
     legend(num2str(o'));

   end
   S_file = 'img/sphericalazimuth.png'; saveas(1, S_file);
   ans = S_file;
 #+END_SRC
#+attr_org: :width 500
#+RESULTS: sphericalazimuth test
 [[file:img/sphericalazimuth.png]]
*** Tips
*** Alternatives
*** See Also
trg, trh


** sphericalharmonic
*** Documentation

file:sphericalharmonic.m: returns a spherical harmonic of given order,
type and normalization

*** Octave definition                                              :internal:

#+BEGIN_SRC octave :tangle sphericalharmonic.m
<<sphericalharmonic doc[:results ascii :post octave comment(s=*this*)]()>>
<<copyright>>
function Y_OAB = sphericalharmonic(N_order, theta_A, phi_B, norm, type)
if nargin < 5
  type = 'complex';
end
if nargin < 4
  norm = 'norm';
end
O = (N_order+1)^2;

%% Normierungsfaktor
N_O = sphericalnormalisation(N_order, norm);

%% Legendrefunktionen
P_OA = sphericallegendre(N_order, theta_A);

%% Deklinationsfunktion
D_OB = sphericalazimuth(N_order, phi_B, type);

%% Speicher klarmachen:
Y_OAB = zeros(O, length(theta_A), length(phi_B));

%% KugelflÃ¤chenfunktion
for o = 1:O
  Y_OAB(o, :, :) = N_O(o) * P_OA(o, :).' * D_OB(o, :);
end
#+END_SRC

#+RESULTS:

*** Interface test                                                 :internal:
#+name: sphericalharmonic numeric test
#+BEGIN_SRC octave :results output
N_order = 2
A = 50; theta_A = linspace(0, pi, A);
B = 150; phi_B = linspace(0, 2*pi, B);
S_norm = 'norm';
S_type = 'complex';
Y_OAB = sphericalharmonic(N_order, theta_A, phi_B, S_norm, S_type);
for n = 0:N_order
  for m = 0:n
 
    % m > 0
    op = n^2+n+m+1;
    % m < 0
    om = n^2+n-m+1;
 
    % hermitisch-Test
    if m == 0
	 Z_OAB(op, :, :) = Y_OAB(op, :, :);
    else
	 Z_OAB(op, :, :) = (-1)^m * conj(Y_OAB(om, :,:));
	 Z_OAB(om, :, :) = (-1)^m * conj(Y_OAB(op, :,:));
    end
 
    % reell-Test I
    if m == 0
	 X_OAB(op, :, :) = Y_OAB(op, :, :);
    else
	 X_OAB(op, :, :) = (-1)^m / sqrt(2) * ...
          (Y_OAB(op, :, :) + conj(Y_OAB(op, :, :)));
	 X_OAB(om, :, :) = (-1)*i*(-1)^m /(sqrt(2)) * ...
          (Y_OAB(op, :, :) - conj(Y_OAB(op, :, :)));
    end

    % reell-Test II
    if m == 0
	 W_OAB(op, :, :) = Y_OAB(op, :, :);
    else
	 W_OAB(op, :, :) = (-1)^m / sqrt(2) * ...
          (Y_OAB(op, :, :) + (-1)^m * Y_OAB(om, :, :));
	 W_OAB(om, :, :) = -i / sqrt(2) * ...
          ((-1)^m * Y_OAB(op, :, :) - Y_OAB(om, :, :));
    end

  end
end

if sum(sum(sum(abs(X_OAB-S_OAB)))) > 10^-8
  disp('real valued harmonics I failed!');
end
if sum(sum(sum(abs(W_OAB-S_OAB)))) > 10^-8
  disp('real valued harmonics II failed!');
end
if sum(sum(sum(abs(Y_OAB-Z_OAB)))) > 10^-8
  disp('Y is not hermitian!');
end
#+END_SRC

 #+RESULTS: sphericalharmonic numeric test

*** Documenation                                                     :ignore:
#+name: sphericalharmonic doc
#+BEGIN_SRC org
,*** Syntax
: Y_OAB = sphericalharmonic(N_order, theta_A, phi_B, norm, type)
,*** Description

If the number of input arguments is < 5, the calculation would be done
for a 'complex' type of a spherical harmonic. If the number of input
arguments is < 4, the calculation would be done for a 'norm'
normalization type case.

Harmonics are returned in rows of p (e.g. row = 1 -> m = 0, row = 2 ->
m = 1) after e.g. Poletti.

,*** Input Arguments
- N_order :: Ambisonics order
- theta_A :: vector representing the calculation range of inclination theta
- phi_B :: vector representing the calculation range of azimuth phi
- norm :: string with type of normalization: 
          | 'norm'                | fully normalized                      |
          | 'N3D'                 | normalized                            |
          | 'sch0' or 'SN3D'      | seminormalazed                        |
          | 'sch1'                | Schmidt-Semi-normalized (Matlab(tm))  |
          | 'sconv'               | norm. over all spherical convolutions |
          | 'planewave_impinging' | norm. for plane waves                 |
- type :: type of the spherical harmonic: 
          |'real', 'real_signed', 'real_unsigned'  or 'complex'|
,*** Return Values
- Y_OAB :: matrix of the spherical harmonics values
#+END_SRC

#+call: sphericalharmonic doc[:output html]()

*** Examples
 #+name: sphericalharmonic booast surface test
 #+BEGIN_SRC octave :tangle sphericalharmonicbooastsurfacetest.m :var S_file="img/sphereharmsurf.png" :results file
%% spherical harmonics
N_order = 2;
A = 50; theta_A = linspace(0, pi, A);
B = 150; phi_B = linspace(0, 2*pi, B);
S_norm = 'norm';
S_type = 'complex';
Y_OAB = sphericalharmonic(N_order, theta_A, phi_B, S_norm, S_type);

%% Vectorgrid for a unitsphere
vg = vectorgrid(1, theta_A, phi_B, 'spherical');

%% draw
figure(1); clf;
for n = 0:N_order
  for m = -n:n
    o = n^2+n+m+1;
    subplot(N_order + 1, 2*N_order + 1, (N_order+1)+n*(2*N_order+1)+m);
    Y_AB = Y_OAB(o, :, :);
    % surface(vg, abs(real(Y_AB)), sign(real(Y_AB)), 'dependendSurface');
    surface(vg, abs(real(Y_AB)), [], 'dependendSurface');
    xlabel('x');
    ylabel('y');
    zlabel('z');
    title(sprintf('|Re Y| n = %i, m = %i', n, m));
    view([30 40]);
    grid('on');
    axis('equal');
  end
end
<<save S_file>>
#+END_SRC

#+caption: Spherical harmonic functions shown as functions of the radius.
#+attr_org: :width 500
#+RESULTS: sphericalharmonic booast surface test
[[file:img/sphereharmsurf.png]]

*** Tips
*** Alternatives
*** See Also
sphericalnormalisation, sphericallegendre, sphericalazimuth




* Spherical Series
** Sphericalseries_hoa_plane


#+name: spherical series hoa planewave test
#+BEGIN_SRC octave
% Rasta
% -------------------------------------------------------------------

% conus
if 1
  R_max = 1.5;
  C = 30; r_C = linspace(0, R_max, C);
  A = 1;  theta_A = linspace(pi/2, pi/2, A);
  B = 40; phi_B = linspace(0, 2*pi,    B);
  gg_CAB = vectorgrid(r_C, theta_A, phi_B, 'spherical');
end

% sphere
if 0
  R_max = 0.15;
  C = 1; r_C = linspace(R_max, R_max, C);
  A = 30;  theta_A = linspace(0, pi, A);
  B = 40; phi_B = linspace(0, 2*pi,  B);
  gg_CAB = vectorgrid(r_C, theta_A, phi_B, 'spherical');
end

% Spherical stuff
% -------------------------------------------------------------------
N_order = 4;
F = 1;
f_F = linspace(100, 1000, F); % Frequenzen
k_F = -2*pi*f_F/342; % Wellenzahl

% ebene Welle
% -------------------------------------------------------------------
Theta_i = pi/3;
Phi_i = pi/2;
S_norm = 'norm';
S_type = 'complex';
A_OF = sphericalseries_hoa_plane(N_order, Theta_i, Phi_i, ...
                                 S_norm, S_type, F);

% SphÃ¤rische-Fouriertransformations-Coeffizienten (sfc)
% -------------------------------------------------------------------
C_OCF = sphericalseries_sfc(A_OF, [], r_C, inf, k_F);

% inverse sphÃ¤rische Fouriertransformation (isf)
% -------------------------------------------------------------------

% Basisfunktion
Y_OAB = sphericalharmonic(N_order, theta_A, phi_B, S_norm, S_type);

% ISF im Frequenzbereich
P_CABF = sphericalseries_isf(C_OCF, Y_OAB);

% ISF im Zeitbereich
c_OCF = ifft(C_OCF, [], 3);
p_CABF = sphericalseries_isf(c_OCF, Y_OAB);
      

% malen
% -------------------------------------------------------------------
if 1
  for f = 1:F
    figure(f);
    vectorgrid_surface(gg_CAB, squeeze(abs(real(P_CABF(:,:,:,f)))));
    axis('equal');
    grid('on');
    view([30 30]);
  end
end

#+END_SRC

** sphericalseries_hoa_spherical
** sphericalseries_hoa_basis

file:sphericalseries_hoa_basis.m: returns spherical basis functions R = j_n Y and S = h_n Y

*** Octave definition                                              :internal:

#+BEGIN_SRC octave :tangle sphericalseries_hoa_basis.m
<<sphericalseries_hoa_basis doc[:results ascii :post octave comment(s=*this*)]()>>
<<copyright>>

function [R_OCABF, S_OCABF] = sphericalseries_hoa_basis(N_order, R_src, ...
                                               vg_CAB, k_F, ...
                                               S_norm, S_type)

  if strcmp(vectorgrid_type(vg_CAB), 'spherical')
    
    [r_C, theta_A, phi_B] = vectorgrid_grid(vg_CAB);
    
    ind_ext  = find(r_C <= R_src); % exterior case
    ind_int  = find(r_C >  R_src); % interior case
    
    % Basisfunktionen als Summanden der inversen
    % sph. Fouriertransformation mit den Funktionen j_n und h_n
    % berechnet:
    Y_OAB = sphericalharmonic(N_order, theta_A, phi_B, S_norm, S_type);

    if ~isempty(ind_ext)
      j_OCF = sphericalbessel(N_order, r_C(ind_ext).'*k_F);
      R_OCABF = sphericalseries_isfs(j_OCF, Y_OAB);
    else 
      R_OCABF = [];
    end

    if ~isempty(ind_int)
      h_OCF = sphericalhankel(N_order, r_C(ind_int).'*k_F);
      S_OCABF = sphericalseries_isfs(h_OCF, Y_OAB);
    else
      S_OCABF = [];
    end
  else 
    error('Vectorgrid need to be spherical (at least in a way...).');
  end
#+END_SRC
*** Interface test                                                 :internal:

*** Documenation                                                     :ignore:
#+name: sphericalseries_hoa_basis doc
#+BEGIN_SRC org
,*** Syntax

,*** Description
: [R_OCABF, S_OCABF] = sphericalseries_hoa_basis(N_order, R_src, ...
:                                            vg_CAB, k_F, ...
:                                            S_norm, S_type)
 
returns spherical basis functions R = j_n Y and S = h_n Y
    
,*** Input Arguments

,*** Return Values

,*** Examples

,*** Tips

,*** Alternatives

,*** See Also
#+END_SRC

#+call: sphericalseries_hoa_basis doc[:output html]()

** sphericalseries_hoa

file:sphericalseries_hoa.m: calculates something for given argument

*** Octave definition                                              :internal:

#+BEGIN_SRC octave :tangle sphericalseries_hoa.m
<<sphericalseries_hoa doc[:results ascii :post octave comment(s=*this*)]()>>
<<copyright>>
function p_CABF = sphericalseries_hoa(C_OF, F_OCABF, D_OF, G_OCABF)
  
  if length(size(F_OCABF)) < 3
    error('Function basis needs at least 3 dimensions.');
  end
  
  % berechne Ergebnis der Reihenentwicklung mit Koeffizienten C mit
  % Funktionsbasis F:
  if ~isempty(F_OCABF)
    p_CABF = sphericalseries(C_OF, F_OCABF);
  else
    p_CABF = [];
  end
  
  % falls zwei Koeffzi. und Basen Ã¼bergeben, weitere Berechnung:
  if nargin == 4
    
    if ~isempty(G_OCABF)
      q_CABF = sphericalseries(D_OF, G_OCABF);
    else
      q_CABF = [];
    end

    % concatiniere 8) Ergebnis: 
    p_CABF = [p_CABF; q_CABF];
  end
  
function p_CABF = sphericalseries(C_OF, F_OCABF)
% bestimme GrÃ¶Ãe der Eingangsmatrizen 
  C = size(F_OCABF, 2);
  A = size(F_OCABF, 3);
  B = size(F_OCABF, 4);
  F = size(F_OCABF, 5);
  p_CABF = zeros(C, A, B, F);
  for f = 1:F
    for c = 1:C
      for a= 1:A
        for b = 1:B
          p_CABF(c, a, b, f) = C_OF(:,f).' *  F_OCABF(: ,c, a, b, f);
        end
      end
    end
  end
#+END_SRC
*** Interface test                                                 :internal:
*** Documenation                                                     :ignore:

#+name: sphericalseries_hoa doc
#+BEGIN_SRC org
,*** Syntax

: p_CABF = sphericalseries_hoa(C_OF, F_OCBAF, D_OF, G_OCBAF)

,*** Description

returns result of HOA series with coefficients C and D und basis
functions F and G. The second pair (D and G) is optional.

,*** Input Arguments

,*** Return Values

,*** Examples

,*** Tips

,*** Alternatives

,*** See Also
#+END_SRC

#+call: sphericalseries_hoa doc[:output html]()



** sphericalseries_sfc
* Examples
