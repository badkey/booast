#+TITLE: Spherical Series
#+DATE: <2017-11-23 Do> Rev. Time-stamp: <2021-09-14 02:29:20 jbatke>
#+AUTHOR: Johann-Markus Batke
#+EMAIL: JBatke@technik-emden.de
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 25.2.2 (Org mode 9.1.3)
#+setupfile: octavetemplates.org
#+setupfile: booast.setup
#+exclude_tags: internal
#+property: header-args:org               :eval export :exports results
#+PROPERTY: header-args:octave :noweb yes :eval no-export

* General Information
This is all about Higher Order Ambisonics.

We need to implement some math.
* Spherical Mathematics

** Fourier Bessel Series
Spherical Series provides means to calculate the "Fourier Bessel
Series".  The form of this series is
\begin{equation}
  \label{eq:fbs}
  P(r, \theta, \phi, k) = \sum_{n = 0}^{\infty} \sum_{m = -n}^{n} 
  \left\{\begin{array}{ll}
  A_{n}^{m}(k) & j_n(kr) \\
  B_{n}^{m}(k) & h_n(kr) \\
  \end{array}\right\}
  Y_{n}^{m}(\theta, \phi).
\end{equation}

In particular, we have
- $A_{n}^{m}(k)$ coefficients describing a soundfield outside 
- $B_{n}^{m}(k)$ coefficients describing a soundfield inside
- $j_n(kr)$ the spherical bessel function
- $h_n(kr)$ the spherical hankel function
- $Y_{n}^{m}(\theta, \phi)$ spherical harmonics
- $k = \omega/\mathrm c$ wavenumber
- $\mathrm c$ speed of sound

** HOA Series

The product $j_n(kr) \, Y_{n}^{m}(\theta, \phi)$ may combined to a
basefunction $R_n^m(r, \theta, \phi, k)$ and $h_n(kr) \,
Y_{n}^{m}(\theta, \phi)$ is combined to basefunction $S_n^m(r, \theta,
\phi, k)$ yielding
\begin{equation}
  \label{eq:1r}
  P(r, \theta, \phi, k) = \sum_{n = 0}^{\infty} \sum_{m = -n}^{n} 
  \left\{\begin{array}{ll}
      A_{n}^{m}(k) & R_n^m(r, \theta, \phi, k)\\
      B_{n}^{m}(k) & S_n^m(r, \theta, \phi, k)\\
  \end{array}\right. .
\end{equation}

** Spherical Fourier Transform

The *inverse spherical Fourier Transform* is defined as
\begin{equation}
  \label{eq:isfs}
  P(r, \theta, \phi, k) = \sum_{n = 0}^{\infty} \sum_{m = -n}^{n} 
  P_{n}^{m}(k,r) 
  Y_{n}^{m}(\theta, \phi).
\end{equation}
as found in cite:williams99_fourier_acoustic p. 208 equation (6.96). 

Combination of $A_{n}^{m}(k)$ and $j_n(kr)$ results in Fourier
coefficients used in the inverse transform
\begin{equation}
  \label{eq:sfs}
  P(r, \theta, \phi, k) = \sum_{n = 0}^{\infty} \sum_{m = -n}^{n} 
  \left\{\begin{array}{ll}
  C_{n}^{m}(k,r) \\
  D_{n}^{m}(k,r) \\
  \end{array}\right\}
  Y_{n}^{m}(\theta, \phi).
\end{equation}

* Spherical Functions
** sphericalbesselj
file:sphericalbesselj.m: calculate spherical bessel function at order N

*** Octave definition                                              :internal:

#+BEGIN_SRC octave :tangle sphericalbesselj.m
<<sphericalbesselj doc[:results ascii :post octave comment(s=*this*)]()>>
<<copyright>>

function J_sph_CF = sphericalbesselj(N_order, x_CF)
  
  C = size(x_CF, 1);
  F = size(x_CF, 2);
  L = C*F;
  x_L = reshape(x_CF, 1, L);
  J_sph_L = zeros(L, 1);
  
  % finde Nullen im Argument
  idx_zero = (x_L == 0);

  % Ergebnis zuweisen
  if N_order == 0
    J_sph_L(idx_zero) = 1;
  else
    J_sph_L(idx_zero) = 0;
  end

  % finde den Rest
  idx_nzero = (x_L ~= 0);

  % Ergebnis zuweisen
  J_sph_L(idx_nzero) = sqrt(pi ./ (2*x_L(idx_nzero))) .* ...
      besselj(N_order + 0.5, x_L(idx_nzero));

  % Form retten
  J_sph_CF = reshape(J_sph_L, C, F);

#+END_SRC

*** Interface test                                                 :internal:
#+BEGIN_SRC octave
N_order = 3;
r_C = linspace(1, 2, 2);
k_F = linspace(1, 2, 2);
J_sph_CF = sphericalbesselj(N_order, r_C'*k_F);
ans = size(J_sph_CF);
#+END_SRC

#+RESULTS:
| 2 | 2 |

*** Documenation                                                     :ignore:

#+name: sphericalbesselj doc
#+BEGIN_SRC org
,*** Syntax
: J_sph_CF = sphericalbesselj(N_order, x_CF);

,*** Description
spherical bessel function at order N

,*** Input Arguments
- x_CF :: C x F matrix

,*** Return Values
- J_sph_CF :: C x F matrix

,*** Examples

,*** Tips

,*** Alternatives

,*** See Also
#+END_SRC

#+call: sphericalbesselj doc[:output html]()

**** Examples

Calculate the sphericalbessel function of order 6.
#+name: sphericalbesselj example
#+BEGIN_SRC octave :exports code
N_order = 6;
x_F = linspace(0, 15, 200);
J_sph_OF = sphericalbesselj(N_order, x_F);
#+END_SRC

This results in a graph like Figure [[ref:fig:sphbesselexa6][spherical bessel function]].

#+BEGIN_SRC octave :results file :exports results
figure(1);
plot(x_F, J_sph_OF);
xlabel('x');
ylabel('j_6(x)');
S_file = 'img/sphericalbesselj.png';
saveas(1, S_file);
ans = S_file;
#+END_SRC
#+attr_org: :width 300
#+caption: The spherical bessel function of order 6.
#+caption: label:fig:sphbesselexa6
#+RESULTS:
[[file:img/sphericalbesselj.png]]

** sphericalbessel
file:sphericalbessel.m: wrapper for sphericalbesselj, return all bessel functions orders up to N


*** Octave definition                                              :internal:

#+BEGIN_SRC octave :tangle sphericalbessel.m
<<sphericalbessel doc[:results ascii :post octave comment(s=*this*)]()>>
<<copyright>>
function J_sph_OCF = sphericalbessel(N_order, x_CF)

  if length(size(x_CF)) > 2
    error('Input argument must not have more than 2 dimensions.');
  end
  
  % Speicher
  O = (N_order+1)^2;
  C = size(x_CF, 1);
  F = size(x_CF, 2);
  J_sph_OCF = zeros(O, C, F);
  
  for n = 0:N_order
    J_CF = sphericalbesselj(n, x_CF);
    for m = -n:n
      J_sph_OCF(n^2+n+m+1, :, :) = J_CF;
    end
  end
#+END_SRC

*** Interface test                                                 :internal:

#+BEGIN_SRC octave
N_order = 3;
r_C = linspace(1, 2, 2);
k_F = linspace(1, 2, 2);
J_sph_OCF = sphericalbessel(N_order, r_C'*k_F);
ans = size(J_sph_OCF);
#+END_SRC

#+RESULTS:
| 16 | 2 | 2 |

*** Documenation                                                     :ignore:

#+name: sphericalbessel doc
#+BEGIN_SRC org
,*** Syntax
    : J_sph_OCF = sphericalbessel(N_order, x_CF)

,*** Description
    calculate spherical besselfunction of order N_order along matrix x_CF.
,*** Input Arguments
    - N_order :: order
    - x_CF :: matrix with arguments
,*** Return Values
    - J_sph_OCF :: matrix of all orders 0 up to $(N_order+1)^2$ and input dimensions CF

,*** Examples 
    : N_order = 6;
    : x_F = linspace(0, 15, 200);
    : J_sph_OF = sphericalbessel(N_order, x_F);
   
,*** Tips

,*** Alternatives

,*** See Also
#+END_SRC


#+call: sphericalbessel doc[:output html]()

calculate all spherical bessel functions up to order 6.
#+name: spherical bessel example
#+BEGIN_SRC octave :exports code
N_order = 6;
x_F = linspace(0, 15, 200);
J_sph_OF = sphericalbessel(N_order, x_F);
#+END_SRC

#+BEGIN_SRC octave  :results file :exports results
<<spherical bessel example>>
figure(1);
plot(x_F, J_sph_OF);
xlabel('x');
ylabel('j_6(x)');
xlim([0, 15]);
S_file = 'img/sphericalbessel.png';
saveas(1, S_file);
ans = S_file;
#+END_SRC
#+attr_org: :width 300
#+caption: Spherical bessel functions up to order 6.
#+RESULTS: spherical bessel functions
    [[file:img/sphericalbessel.png]]

** sphericalbessely
file:sphericalbessely.m: compute the spherical Bessel function of the second kind

*** Octave definition                                              :internal:

#+BEGIN_SRC octave :tangle sphericalbessely.m
<<sphericalbessely doc[:results ascii :post octave comment(s=*this*)]()>>
<<copyright>>

function N_sph = sphericalbessely(n, x)

  idx_zero = find(x == 0);
  if length(idx_zero) ~= 0
    disp(['sphericalneumann: found zeros in input argument: setting ' ...
          'to NaN!']);
    idx_zero
    x(idx_zero) = nan;
  end
  
  % sph. Besselfunktion der 2. Art für pos. Arg.
  N_sph = (pi ./ (2*abs(x))).^0.5 .* bessely(n + 0.5, abs(x));

  % finde neg. Arg.
  idx_neg = (x < 0);
  
  % Vorzeichen für neg. Arg. retten (vlg. Gumerov/Duraiswami Glg. 2.1.90)
  N_sph(idx_neg) = (-1)^(n+1) * N_sph(idx_neg);

  N_sph = reshape(N_sph, size(x));
#+END_SRC

*** Interface test                                                 :internal:

#+BEGIN_SRC octave
n = 3;
x = linspace(0, 10);
N_sph = sphericalbessely(n, x);
ans = size(N_sph);
#+END_SRC

#+RESULTS:
| 1 | 100 |

*** Documenation                                                     :ignore:

#+name: sphericalbessely doc
#+BEGIN_SRC org
,*** Syntax

: N_sph = sphericalbessely(n, x)

,*** Description

2nd kind Bessel function is computed for each element of x.If the input argument
(element of a matrix x) is = 0, the output has a value NaN.

,*** Input Arguments

- n - Ambisonics order
- x - matrix to return the result (should not have more than 2 dimensions)

,*** Return Values

- N_sph - matrix of the 2nd kind Bessel function values

,*** Examples

,*** Tips

,*** Alternatives

,*** See Also

bessely
#+END_SRC

#+call: sphericalbessely doc[:output html]()

** sphericalneumann

file:sphericalneumann.m: 2nd kind Bessel function for Ambisonics
coefficients are given as a vector up to order N.

*** Octave definition                                              :internal:

#+BEGIN_SRC octave :tangle sphericalneumann.m
<<sphericalneumann doc[:results ascii :post octave comment(s=*this*)]()>>
<<copyright>>
function N_sph_OCF = sphericalneumann(N_order, x_CF)

  if length(size(x_CF)) > 2
    error('Input argument must not have more than 2 dimensions.');
  end

  % Speicher
  O = (N_order+1)^2;
  C = size(x_CF, 1);
  F = size(x_CF, 2);
  N_sph_OCF = zeros(O, C, F);

  for n = 0:N_order
    N_CF = sphericalbessely(n, x_CF);
    for m = -n:n
      N_sph_OCF(n^2+n+m+1, :, :) = N_CF;
    end
  end
#+END_SRC

*** Interface test                                                 :internal:

#+BEGIN_SRC octave
N_order = 3;
x_CF = ones(4, 5);
N_sph_OCF = sphericalneumann(N_order, x_CF);
ans = size(N_sph_OCF);
#+END_SRC

#+RESULTS:
| 16 | 4 | 5 |

*** Documenation                                                     :ignore:

#+name: sphericalneumann doc
#+BEGIN_SRC org
,*** Syntax

: N_sph_OCF = sphericalneumann(N_order, x_CF)

,*** Description

First derivative of the 2nd kind Bessel function is computed for each
element of x.If the input argument (element of a matrix x) is = 0, the
output has a value NaN.

,*** Input Arguments

- N_order - Ambisonics order
- x_CF - matrix to return the result (should not have more than 2 dimensions)

,*** Return Values

- N_sph_OCF - multi-dimensional matrix with Neumann function calculation results

,*** Examples

,*** Tips

,*** Alternatives

,*** See Also
sphericalbessely
#+END_SRC

#+call: sphericalneumann doc[:output html]()

** sphericalhankel
file:sphericalhankel.m: returns the Bessel function of the 3rd kind (Hankel function) 

*** Octave definition                                              :internal:

#+BEGIN_SRC octave :tangle sphericalhankel.m
<<sphericalhankel doc[:results ascii :post octave comment(s=*this*)]()>>
<<copyright>>
function h_OCF = sphericalhankel(n, x_CF)

h_OCF = sphericalbessel(n, x_CF) + i*sphericalneumann(n, x_CF);
#+END_SRC
*** Interface test                                                 :internal:

#+BEGIN_SRC octave
n = 3;
x_CF = ones(4, 5);
h_ocf = sphericalhankel(n, x_CF);
ans = size(h_ocf);
#+END_SRC

#+RESULTS:
| 16 | 4 | 5 |

*** Documenation                                                     :ignore:

#+name: sphericalhankel doc
#+BEGIN_SRC org
,*** Syntax
: h_OCF = sphericalhankel(n, x_CF)

,*** Description

According to the mathematical definition, Hankel function is obtained be combining two linearly 
independent solutions of Bessel's differential equation (Wikipedia). This is done by means of 
summation spherical bessel function of the 1st kind with spherical bessel function of the 2nd kind,
multiplyed by the imaginary unit.

This calculation is done for all elements of the matrix x_Cf

,*** Input Arguments
- n - Ambisonics order
- x_CF -  matrix to return the result (should not have more than 2 dimensions)

,*** Return Values
- h_OCF - multi-dimensional matrix of calculation results

,*** Examples

,*** Tips

,*** Alternatives

,*** See Also
sphericalbessel, sphericalneumann
#+END_SRC

#+call: sphericalhankel doc[:output html]()
*** Example
Lets calculate all hankel functions up to order 3.

#+name: sphericalhankel example code
#+BEGIN_SRC octave
N_order = 3;
x_max = 15;
x_F = linspace(0, x_max, 200);
h_OF = sphericalhankel(N_order, x_F.');
#+END_SRC

#+RESULTS: sphericalhankel example code

We get an image like shown in Figure [[ref:fig:sphericalhankel][Hankel]].

#+name: figure sphericalhankel 
#+BEGIN_SRC octave :results file :exports results :var S_file="img/sphericalhankelexa.png"
<<sphericalhankel example code>>
figure(1);
subplot(2, 2, 1); plot(x_F, real(h_OF));  xlim([0, x_max]); ylim([-1, 1]); xlabel('x'); ylabel('Re h(x)');
subplot(2, 2, 2); plot(x_F, imag(h_OF));  xlim([0, x_max]); ylim([-1, 1]); xlabel('x'); ylabel('Im h(x)');
subplot(2, 2, 3); plot(x_F, abs(h_OF));   xlim([0, x_max]); ylim([0, 1]); xlabel('x'); ylabel('|h(x)|');
subplot(2, 2, 4); plot(x_F, angle(h_OF)); xlim([0, x_max]); ylim([-1, 1]*pi); xlabel('x'); ylabel('ang h(x)');
xlim([0, x_max]);
<<save S_file>>
#+END_SRC
#+attr_org: :width 300
#+caption: Hankel functions shown as real and imaginary part (top) and as absolute value and angle (bottom).
#+caption: label:fig:sphericalhankel
#+RESULTS: figure sphericalhankel
[[file:img/sphericalhankelexa.png]]

** sphericalbessel_r
file:sphericalbessel_r.m: returns the 1st radial derivative of the spherical Bessel function

cite:williams99_fourier_acoustic

*** Octave definition                                              :internal:


#+BEGIN_SRC octave :tangle sphericalbessel_r.m
<<sphericalbessel_r doc[:results ascii :post octave comment(s=*this*)]()>>
<<copyright>>
  function J_r_OCF = sphericalbessel_r(N_order, x_CF)

  if length(size(x_CF)) > 2
    error('Input argument must not have more than 2 dimensions.');
  end
  
  % Speicher
  O = (N_order+1)^2;
  C = size(x_CF, 1);
  F = size(x_CF, 2);
  J_r_OCF = zeros(O, C, F);
  
  for n = 0:N_order
    J_r_CF = sphericalbesseljr(n, x_CF);
    for m = -n:n
      J_r_OCF(n^2+n+m+1, :, :) = J_r_CF;
    end
  end

function J_r_CF = sphericalbesseljr(n, x_CF)
% sphericalbesseljr - 1st derivative of the spherical Bessel's function of the first kind
%
% J_r_CF = sphericalbesseljr(n, x_CF)
%
% INPUTS
% n - Ambisonics order
% x_CF - matrix to return the result
%
% OUTPUTS
% J_r_CF - matrix of Bessel function's 1st derivative values
%
% DESCRIPTION
% The output matrix has the same dimensions as x_CF. 
% If the input argument (element of a matrix x_CF) is = 0 for the 1st order Ambisonics, resulting
% output would be = 1/3 (L'Hospital rule is applyed), for all other Ambisonics orders the output is 0
%  
% See also: sphericalbesselj

  S_size  = size(x_CF);
  x_L = reshape(x_CF, 1, prod(S_size));
  
  % Sonderbehandlung x == 0
  idx_zero = (x_L == 0);
  if n == 1
    J_r_L(idx_zero) = 1/3; % Sonderfall, mittels l'Hospital
                           % berechnet, ächz!
  else
    J_r_L(idx_zero) = 0;
  end
  
  % Rest
  idx_nzero = (x_L ~= 0);
  J_r_L(idx_nzero) = sphericalbesselj(n-1, x_L(idx_nzero)) - ...
      (n+1) * x_L(idx_nzero).^(-1) .* sphericalbesselj(n, x_L(idx_nzero));

  % Form wahren
  J_r_CF = reshape(J_r_L, S_size);

#+END_SRC
*** Interface test                                                 :internal:
#+BEGIN_SRC octave :results output
N_order = 4;
C = 100;
r_C = linspace(0, 20, C).';
F = 2;
k_F = [1:F];
j_sph_r_OCF = sphericalbessel_r(N_order, r_C*k_F);
whos
#+END_SRC

#+RESULTS:
#+begin_example
Variables in the current scope:

   Attr Name             Size                     Bytes  Class
   ==== ====             ====                     =====  ===== 
        C                1x1                          8  double
        F                1x1                          8  double
        N_order          1x1                          8  double
        ans              1x1                          8  double
        j_sph_r_OCF     25x100x2                  40000  double
        k_F              1x2                         16  double
        r_C            100x1                        800  double

Total is 5106 elements using 40848 bytes

#+end_example

*** Documentation                                                     :ignore:

    #+name: sphericalbessel_r doc
    #+BEGIN_SRC org
    ,*** Syntax

    : J_r_OCF = sphericalbessel_r(N_order, x_CF)
    

    ,*** Description

    Similar with function sphericalbesselj, sphericalbessel_r deals with the case when Ambisonics 
    coefficients are given as a vector. 

    ,*** Input Arguments

    N_order - Ambisonics order
    x_CF -  matrix to return the result (should not have more than 2 dimensions)

    ,*** Return Values
    
    J_r_OCF - multi-dimensional matrix with Bessel function calculation results
    

    ,*** Examples

    ,*** Tips

    ,*** Alternatives

    ,*** See Also
    
    sphericalbesseljr
    #+END_SRC

    #+call: sphericalbessel_r doc[:output html]()

** sphericalnormalisation

=sphericalnormalisation= - calculates the normalization factor 
file:./sphericalnormalisation.m

*** Octave definition                                              :internal:
#+BEGIN_SRC octave :tangle sphericalnormalisation.m 
<<sphericalnormalisation doc[:results ascii :post octave comment(s=*this*)]()>>
<<copyright>>

function N_O = sphericalnormalisation(N_order, norm)
  if nargin < 2
    norm = 'norm';
  end
  N_O = zeros((N_order+1)^2, 1);

  if strcmp(norm, 'norm')
    % fully normalised
    for n = 0:N_order
	 for m = -n:n
        o = n^2+n+m+1;
        N_O(o) = (-1)^m * sqrt((2*n + 1)/(4*pi) * ...
			 factorial(n-abs(m))/...
			 factorial(n+abs(m)));
	 end
    end
 
  elseif strcmpi(norm, 'N3D')
    % 3D after Daniel
    % führt zu Energie = 4 pi
    for n = 0:N_order
	 for m = -n:n
        o = n^2+n+m+1;
        N_O(o) = sqrt((2*n + 1) * ...
			 factorial(n-abs(m))/...
			 factorial(n+abs(m)));
	 end
    end  

  elseif strcmpi(norm, 'SN3D')
    % Schmidt semi norm, see Wikipedia
    % SN3D
    for n = 0:N_order
	 for m = -n:n
        o = n^2+n+m+1;
        N_O(o) = sqrt(factorial(n-abs(m))/...
			 factorial(n+abs(m)));
	 end
    end  

  elseif strcmp(norm, 'sch1')
    % Schmidt semi norm, siehe Matlab -- mit Wurzel 2
    for n = 0:N_order
	 for m = -n:n
        o = n^2+n+m+1;
        if m ~= 0
          N_O(o) = sqrt(2*factorial(n-abs(m))/...
                        factorial(n+abs(m)));
        else
          N_O(o) = 1;
        end
	 end
    end  

  elseif strcmp(norm, 'sconv')
    % spherical convolution
    for n = 0:N_order
	 for m = -n:n
        o = n^2+n+m+1;
        N_O(o) = (2*pi) * sqrt((4*pi)/(2*n + 1));
	 end
    end  

  elseif strcmp(norm, 'planewave')
    % plane wave
    for n = 0:N_order
	 for m = -n:n
        o = n^2+n+m+1;
        N_O(o) = 4*pi*1i^n;
	 end
    end  

  else
    error('Unknown norm ''%s''', norm);
  end

 #+END_SRC

 #+RESULTS:
*** Interface test                                                 :internal:

 #+name: sphericalnormalisation test
 #+BEGIN_SRC octave 
 N_order = 1;
 S_norm = 'norm';
 sphericalnormalisation(N_order, S_norm)
 #+END_SRC

 #+RESULTS: sphericalnormalisation test
 | 0.2820947917738781 |
 | 0.3454941494713355 |
 | 0.4886025119029199 |
 | 0.3454941494713355 |

*** Documentation                                                    :ignore:

#+name: sphericalnormalisation doc
#+BEGIN_SRC org :exports results 
,*** Syntax
: N_O = sphericalnormalisation(N_order, norm)

,*** Description
Calculates the normalization factor for a given harmonic order and
normalization type.  If the type of normalization is not defined at
the output, full normalization 'norm' will be performed.

,*** Input Arguments
- N_order :: order of a spherical harmonic
- norm :: type of normalization: 
  | 'norm'                | fully normalized;                     |
  | 'N3D'                 | normalized;                           |
  | 'sch0' or 'SN3D'      | seminormalazed                        |
  | 'sch1'                | Schmidt-Semi-normalized (Matlab)      |
  | 'sconv'               | norm. over all spherical convolutions |
  | 'planewave_impinging' | norm. for plane waves                 |

,*** Return Values
  - N_O - corresponding normalization factor
#+END_SRC

#+call: sphericalnormalisation doc[:output html]()
*** Examples
*** Tips
*** Alternatives
*** See Also

** sphericallegendre

file:sphericallegendre.m: calculates spherical Legendre functions

*** Octave definition                                              :internal:
#+BEGIN_SRC octave :tangle sphericallegendre.m
<<sphericallegendre doc[:results ascii :post octave comment(s=*this*)]()>>
<<copyright>>

 function P_OA = sphericallegendre(N_order, theta_A)

   O = (N_order+1)^2;
   A = length(theta_A);  % Anzahl der theta Werte
   P_OA = zeros(O, A);   % Legendre polynom 1. art
   Q_OA = zeros(O, A);   % Legendre polynom 2. art
  
   for n = 0:N_order % order index
     % legendre polynomial includes the (-1)^m term
     P_QA = legendre(n, cos(theta_A));
     % size: (n+1)xA
     % P_n^m(cos(theta_A)) is row m+1; m = 0..n
     % see: http://www.mathworks.com/help/techdoc/ref/legendre.html
     % P_n^m(x) = (-1)^m (1-x^2)^{m/2} \frac{\mathrm d^m}{\mathrm d x^m} P_n(x).
    
     % Indices triangle shaped left, mid, right
     o_l = n^2+1;     % 1 + ACN(n, m=-n); ACN(n, m) = n*(n+1) + m;
     o_m = n^2+n+1;   % 1 + ACN(n, m=0)
     o_r = n^2+2*n+1; % 1 + ACN(n, m=+n)

     % m >= 0
     P_OA(o_m:o_r, :) = P_QA;
     if n > 0
         % m < 0
         m = -1:-1:-n;
         fac = repmat((-1).^m(:), 1, A); 
         P_OA([o_m-1:-1:o_l], :) = fac .* P_QA(2:end,:);
     end
   end
#+END_SRC

*** Interface test                                                 :internal:
#+name: sphericallegendre test
#+BEGIN_SRC octave :results file
   N_order = 2;
   theta_A = linspace(0, pi, 90);
   P_OA = sphericallegendre(N_order, theta_A);
   figure(1);
   plot(theta_A, P_OA.'); xlabel('\theta'); ylabel('P_{n}(\theta)')
   S_file = 'img/legendre.png'; saveas(1, S_file);
   ans = S_file;
#+END_SRC
#+attr_org: :width 600
#+RESULTS: sphericallegendre test
[[file:img/legendre.png]]

*** Documenation                                                     :ignore:


#+name: sphericallegendre doc
#+BEGIN_SRC org
,*** Syntax

: P_OA = sphericallegendre(N_order, theta_A)

,*** Description

Resulting matrix of Legendre function values has the dimensions ((N_order+1)^2+1)xlength(theta_A).
For positive odd m a negative sign is used.
No normalization is used.
Regarding normalization the calculation is done for a symmetric calculation of m.

- for $m >= 0$: $P_n^m(\cos(\theta )$  [including $(-1)^m$]
- for $m < 0:$  $(-1)^m P_n^{|m|}(\cos(\theta )$

equivalent to (using legendre polynomial notation without Condon-Shortley phase):
- for $m >= 0$: $(-1)^m P_n,|m|( \cos(\theta )$
- for $m < 0$:  $P_n,|m|( \cos(\theta )$

,*** Input Arguments

- N_order :: order of the spherical harmonic
- theta_A :: vector representing the calculation range of inclination theta

,*** Return Values

- P_OA :: matrix of Legendre function values

,*** Examples
Legendre functions for $n = 0, 1, 2, 3, 4, 5$ according to Figure 6.2
in cite:williams99_fourier_acoustic are shown by the following piece
of code.

,#+name: sphericallegendre figure 6.2 
,#+BEGIN_SRC octave :results file :exports both
   N_order = 5;
   theta_A = linspace(0, pi, 90);
   P_OA = sphericallegendre(N_order, theta_A);

   figure(1);
   n = 0:N_order;
   m = 0;
   o = n.^2 + n + m + 1;
   for l = 1:length(n)
     S_label{l} = sprintf('n = %i, m = %i', n(l), m);
   end
   plot(theta_A, P_OA(o,:)); xlabel('\theta'); ylabel('P_{n}(\theta)'); legend(S_label);
   S_file = 'img/legendrefigure62.png'; saveas(1, S_file);
   ans = S_file;
,#+END_SRC

,#+attr_org: :width 600
,#+caption: Legendre functions for $n = 0, 1, 2, 3, 4, 5$ and $m=0$.
,#+RESULTS: sphericallegendre figure 6.2
[[file:img/legendrefigure62.png]]

Legendre functions for $n = 1, 2, 3, 4, 5, 6$ according to Figure 6.3
in cite:williams99_fourier_acoustic are shown by the following piece
of code.

,#+name: sphericallegendre figure 6.3
,#+BEGIN_SRC octave :results file :exports both
   N_order = 6;
   theta_A = linspace(0, pi, 90);
   P_OA = sphericallegendre(N_order, theta_A);

   figure(1);
   n = 1:N_order;
   m = 1;
   o = n.^2 + n + m + 1;
   for l = 1:length(n)
     S_label{l} = sprintf('n = %i, m = %i', n(l), m);
   end
   plot(theta_A, P_OA(o,:)); xlabel('\theta'); ylabel('P_{n}^m(\theta)'); legend(S_label);
   S_file = 'img/legendrefigure63.png'; saveas(1, S_file);
   ans = S_file;
,#+END_SRC
,#+attr_org: :width 600
,#+RESULTS: sphericallegendre figure 6.3
[[file:img/legendrefigure63.png]]

,*** See Also
legendre 
#+END_SRC

#+call: sphericallegendre doc[:output html]()

** trg

file:trg.m: calculates something for given argument

*** Octave definition                                              :internal:
#+BEGIN_SRC octave :tangle trg.m
<<named doc[:results ascii :post octave comment(s=*this*)]()>>
<<copyright>>
 function y = trg(m, x)
   if m > 0
     y = (-1)^m * sqrt(2) * cos(m*x);
   elseif m < 0
     y = (-1) * sqrt(2) * sin(m*x);
   else % m == 0
     y = 1;
   end
#+END_SRC
*** Interface test                                                 :internal:
tbd
*** Documenation                                                     :ignore:
#+name: named doc
#+BEGIN_SRC org
,*** Syntax
: y = trg(m, x)
,*** Description

,*** Input Arguments

- x : numeric argument
- m : order

,*** Return Values

y
#+END_SRC

#+call: named doc[:output html]()

*** Examples
*** Tips
*** Alternatives
*** See Also
trh

** trh

file:trh.m: calculates something for given argument

*** Octave definition                                              :internal:
#+BEGIN_SRC octave :tangle trh.m
<<named doc[:results ascii :post octave comment(s=*this*)]()>>
<<copyright>>
 function y = trh(m, x)
   if m > 0
     y = sqrt(2) * cos(m*x);
   elseif m < 0
     y = -sqrt(2) * sin(m*x); % = sqrt(2) * sin(abs(m) * x)
   else % m == 0
     y = 1;
   end
#+END_SRC
*** Interface test                                                 :internal:
*** Documenation                                                     :ignore:
#+name: trg doc
#+BEGIN_SRC org
,*** Syntax
,*** Description

real-valued circular harmonics 2D normalised (N2D) of degree m and azimuth x

2D normalised (N2D) as defined in sec. 3.1 of
J. Daniel: 
Spatial Sound Endcoding Including Near Field Effect: Introducing Distance 
coding Filters and a Viable, New Ambisonic Format, 
AES 23rd International Conference, 2003

,*** Input Arguments
- m :: degree
- x :: azimuth

,*** Return Values
- y :: circular harmonic
#+END_SRC

#+call: trg doc[:output html]()

*** Examples
*** Tips
*** Alternatives
*** See Also
trh

** sphericalazimuth

file:sphericalazimuth.m: calculates spherical azimuth of order N for angle phi 

*** Octave definition                                              :internal:
#+BEGIN_SRC octave :tangle sphericalazimuth.m
<<named doc[:results ascii :post octave comment(s=*this*)]()>>
<<copyright>>
 function D_OB = sphericalazimuth(N_order, phi_B, S_type)
 if nargin < 3
   S_type = 'complex';
 end

 D_OB = zeros((N_order+1)^2, length(phi_B));
 switch S_type 
   case 'complex'
     for n= 0:N_order
       for m = -n:n
         o = n^2+n+m+1;
         D_OB(o,:) = exp(1i*m*phi_B);
       end
     end
   case {'real_signed', 'real'}
     for n= 0:N_order
       for m = -n:n
         o = n^2+n+m+1;
         D_OB(o,:) = trg(m, phi_B);
       end
     end
   case 'real_unsigned'
     for n= 0:N_order
       for m = -n:n
         o = n^2+n+m+1;
         D_OB(o,:) = trh(m, phi_B);
       end
     end
   otherwise
     error('Unknown spherical azimuth type %s!', S_type);
 end
#+END_SRC
*** Interface test                                                 :internal:
*** Documenation                                                     :ignore:
#+name: sphericalazimuth doc
#+BEGIN_SRC org
,*** Syntax
: D_OB = sphericalazimuth(N_order, phi_B, S_type)

,*** Description
spherical azimuth of order N for angle phi 

If less than 3 variablrs are defined at the input, calculation is done
for S_type = 'complex' case.

,*** Input Arguments
- N_order :: order of the spherical harmonic
- phi_B :: vector representing the calculation range of azimuth phi ?
- S_type :: type of the spherical harmonic: 'real', 'real_signed', 'real_unsigned'  or 'complex'

,*** Return Values
- D_OB :: matrix with o orders and B angles
#+END_SRC

#+call: sphericalazimuth doc[:output html]()

*** Examples

 #+name: sphericalazimuth test
 #+BEGIN_SRC octave :exports results :results file
   N_order = 2;
   o = 1:(N_order+1)^2;

   B = 128;
   phi_B = linspace(0, 2*pi, B);

   S_type_list{1} = 'complex';
   S_type_list{2} = 'real';

   for n = 1:length(S_type_list)
     D_OB{n} = sphericalazimuth(N_order, phi_B, S_type_list{n});

     figure(n);
     plot(phi_B, real(D_OB{n}.'));
     xlabel('\phi_B');
     ylabel('azimuth');
     title(S_type_list{n});
     legend(num2str(o'));

   end
   S_file = 'img/sphericalazimuth.png'; saveas(1, S_file);
   ans = S_file;
 #+END_SRC
#+attr_org: :width 500
#+RESULTS: sphericalazimuth test
 [[file:img/sphericalazimuth.png]]
*** Tips
*** Alternatives
*** See Also
trg, trh

** sphericalharmonic

file:sphericalharmonic.m: returns a spherical harmonic of given order,
type and normalization

*** Octave definition                                              :internal:

#+BEGIN_SRC octave :tangle sphericalharmonic.m
<<sphericalharmonic doc[:results ascii :post octave comment(s=*this*)]()>>
<<copyright>>
function Y_OAB = sphericalharmonic(N_order, theta_A, phi_B, norm, type)
if nargin < 5
  type = 'complex';
end
if nargin < 4
  norm = 'norm';
end
O = (N_order+1)^2;

%% Normierungsfaktor
N_O = sphericalnormalisation(N_order, norm);

%% Legendrefunktionen
P_OA = sphericallegendre(N_order, theta_A);

%% Deklinationsfunktion
D_OB = sphericalazimuth(N_order, phi_B, type);

%% Speicher klarmachen:
Y_OAB = zeros(O, length(theta_A), length(phi_B));

%% Kugelflächenfunktion
for o = 1:O
  Y_OAB(o, :, :) = N_O(o) * P_OA(o, :).' * D_OB(o, :);
end
#+END_SRC

#+RESULTS:

*** Interface test                                                 :internal:
#+name: sphericalharmonic numeric test
#+BEGIN_SRC octave :results output
N_order = 2
A = 50; theta_A = linspace(0, pi, A);
B = 150; phi_B = linspace(0, 2*pi, B);
S_norm = 'norm';
S_type = 'complex';
Y_OAB = sphericalharmonic(N_order, theta_A, phi_B, S_norm, S_type);
for n = 0:N_order
  for m = 0:n
 
    % m > 0
    op = n^2+n+m+1;
    % m < 0
    om = n^2+n-m+1;
 
    % hermitisch-Test
    if m == 0
	 Z_OAB(op, :, :) = Y_OAB(op, :, :);
    else
	 Z_OAB(op, :, :) = (-1)^m * conj(Y_OAB(om, :,:));
	 Z_OAB(om, :, :) = (-1)^m * conj(Y_OAB(op, :,:));
    end
 
    % reell-Test I
    if m == 0
	 X_OAB(op, :, :) = Y_OAB(op, :, :);
    else
	 X_OAB(op, :, :) = (-1)^m / sqrt(2) * ...
          (Y_OAB(op, :, :) + conj(Y_OAB(op, :, :)));
	 X_OAB(om, :, :) = (-1)*i*(-1)^m /(sqrt(2)) * ...
          (Y_OAB(op, :, :) - conj(Y_OAB(op, :, :)));
    end

    % reell-Test II
    if m == 0
	 W_OAB(op, :, :) = Y_OAB(op, :, :);
    else
	 W_OAB(op, :, :) = (-1)^m / sqrt(2) * ...
          (Y_OAB(op, :, :) + (-1)^m * Y_OAB(om, :, :));
	 W_OAB(om, :, :) = -i / sqrt(2) * ...
          ((-1)^m * Y_OAB(op, :, :) - Y_OAB(om, :, :));
    end

  end
end

if sum(sum(sum(abs(X_OAB-S_OAB)))) > 10^-8
  disp('real valued harmonics I failed!');
end
if sum(sum(sum(abs(W_OAB-S_OAB)))) > 10^-8
  disp('real valued harmonics II failed!');
end
if sum(sum(sum(abs(Y_OAB-Z_OAB)))) > 10^-8
  disp('Y is not hermitian!');
end
#+END_SRC
 
#+RESULTS: sphericalharmonic numeric test

*** Documenation                                                     :ignore:
#+name: sphericalharmonic doc
#+BEGIN_SRC org
,*** Syntax
: Y_OAB = sphericalharmonic(N_order, theta_A, phi_B, norm, type)
,*** Description

If the number of input arguments is < 5, the calculation would be done
for a 'complex' type of a spherical harmonic. If the number of input
arguments is < 4, the calculation would be done for a 'norm'
normalization type case.

Harmonics are returned in rows of p (e.g. row = 1 -> m = 0, row = 2 ->
m = 1) after e.g. Poletti.

,*** Input Arguments
- N_order :: Ambisonics order
- theta_A :: vector representing the calculation range of inclination theta
- phi_B :: vector representing the calculation range of azimuth phi
- norm :: string with type of normalization: 
          | 'norm'                | fully normalized                      |
          | 'N3D'                 | normalized                            |
          | 'sch0' or 'SN3D'      | seminormalazed                        |
          | 'sch1'                | Schmidt-Semi-normalized (Matlab(tm))  |
          | 'sconv'               | norm. over all spherical convolutions |
          | 'planewave_impinging' | norm. for plane waves                 |
- type :: type of the spherical harmonic: 
          |'real', 'real_signed', 'real_unsigned'  or 'complex'|
,*** Return Values
- Y_OAB :: matrix of the spherical harmonics values
#+END_SRC

#+call: sphericalharmonic doc[:output html]()

*** Examples
 #+name: sphericalharmonic booast surface test
 #+BEGIN_SRC octave :tangle sphericalharmonicbooastsurfacetest.m :var S_file="img/sphereharmsurf.png" :results file :exports results
%% spherical harmonics
N_order = 2;
A = 30; theta_A = linspace(0, pi, A);
B = 40; phi_B = linspace(0, 2*pi, B);
S_norm = 'norm';
S_type = 'real';
Y_OAB = sphericalharmonic(N_order, theta_A, phi_B, S_norm, S_type);

%% Vectorgrid for a unitsphere
vg = vectorgrid(1, theta_A, phi_B, 'spherical');

%% draw
figure(1); clf;
for n = 0:N_order
  for m = -n:n
    o = n^2+n+m+1;
    subplot(N_order + 1, 2*N_order + 1, (N_order+1)+n*(2*N_order+1)+m);
    Y_AB = Y_OAB(o, :, :);
    % surface(vg, abs(real(Y_AB)), sign(real(Y_AB)), 'dependendSurface');
    surface(vg, abs(real(Y_AB)), [], 'dependendSurface');
    % xlabel('x');
    % ylabel('y');
    % zlabel('z');
    title(sprintf('n = %i, m = %i', n, m));
    view([30 40]);
    grid('on');
    axis('equal');
    axis('nolabel');
  end
end
<<save S_file>>
#+END_SRC

#+caption: Spherical harmonic functions shown as functions of the radius in.
#+attr_org: :width 800
#+RESULTS: sphericalharmonic booast surface test
[[file:img/sphereharmsurf.png]]

*** Tips
*** Alternatives
*** See Also
sphericalnormalisation, sphericallegendre, sphericalazimuth

** sphericalmodematrix
file:sphericalmodematrix.m: calculates something for given argument


*** Octave definition                                              :internal:

#+BEGIN_SRC octave :tangle sphericalmodematrix.m
<<sphericalmodematrix doc[:results ascii :post octave comment(s=*this*)]()>>
<<copyright>>
function Psi_OL = sphericalmodematrix(N_order, theta_L, phi_L, S_norm, S_type)
  if nargin < 5
    type = 'complex';
  end
  if nargin < 4
    norm = 'norm';
  end

  % Normierungsfaktor
  N_O = sphericalnormalisation(N_order, S_norm);
  
  % Legendrefunktionen
  P_OL = sphericallegendre(N_order, theta_L);

  % Deklinationsfunktion
  D_OL = sphericalazimuth(N_order, phi_L, S_type);

  % Kugelflächenfunktion
  Y_OL = diag(N_O) * P_OL .* D_OL;

  Psi_OL = conj(Y_OL);
#+END_SRC

*** Interface test                                                 :internal:

#+BEGIN_SRC octave
N_order = 3;
theta_D = pi;
phi_D = pi;
S_norm = 'N3D';
S_type = 'complex';
Psi_OL = sphericalmodematrix(N_order, theta_D, phi_D, S_norm, S_type);
ans = size(Psi_OL);
#+END_SRC

#+RESULTS:
| 16 | 1 |

*** Documenation                                                     :ignore:

#+name: sphericalmodematrix doc
#+BEGIN_SRC org
,*** Syntax

: Psi_OL = sphericalmodematrix(N_order, theta_L, phi_L, S_norm, S_type)


% $Id$
,*** Description

sphericalmodematrix - returns Ambisonics complex conjugate values

,*** Input Arguments
- N_order -  Ambisonics order
- theta_L - vector representing the calculation range of inclination theta
- phi_L - vector representing the calculation range of azimuth phi
- S_norm - string with type of normalization: 'norm' - fully normalized; 
                                             'N3D'- normalized; 
                                             'sch0' or 'SN3D'- seminormalazed
                                             'sch1'- Schmidt-Semi-normalized (Matlab)
                                             'sconv' - norm. over all spherical convolutions
                                             'planewave_impinging' - norm. for plane waves

,*** Return Values
- Psi_OL - matrix of complex conjugate spherical harmonics values

,*** Examples

,*** Tips

,*** Alternatives

,*** See Also
sphericalharmonic

#+END_SRC

#+call: sphericalmodematrix doc[:output html]()

* Spherical Fourier Transform
** sphericalseries_isfs
file:sphericalseries_isfs.m: calculate spherical series functions summands

*** Octave definition                                              :internal:

#+BEGIN_SRC octave :tangle sphericalseries_isfs.m
<<sphericalseries_isfs doc[:results ascii :post octave comment(s=*this*)]()>>
<<copyright>>
function F_OCABF = sphericalseries_isfs(f_OCF, Y_OAB)

  O = size(f_OCF, 1);
  C = size(f_OCF, 2);
  F = size(f_OCF, 3);
  A = size(Y_OAB, 2);
  B = size(Y_OAB, 3);
  F_OCABF = zeros(O, C, A, B, F);
  
  for o = 1:O
    for c = 1:C
      for f = 1:F
        F_OCABF(o, c, 1:A, 1:B, f) = f_OCF(o,c,f) * Y_OAB(o, 1:A, 1:B);
      end
    end
  end
#+END_SRC
*** Interface test                                                 :internal:

#+BEGIN_SRC octave
N_order = 1;
R_src = 1;
vg_CAB =
k_F = 1;
S_norm = 'norm';
S_type = 'complex';
#+END_SRC
*** Documenation                                                     :ignore:

#+name: sphericalseries_isfs doc
#+BEGIN_SRC org
,*** Syntax
: F_OCABF = sphericalseries_isfs(f_OCF, Y_OAB)

,*** Description
precalculation of ISF

,*** Input Arguments
- f_OCF :: spherical fourier series coefficient
- Y_OAB :: spherical harmonics

,*** Return Values
- F_OCABF :: intermediate result

,*** Examples

,*** Tips

,*** Alternatives

,*** See Also
#+END_SRC

#+call: sphericalseries_isfs doc[:output html]()


** sphericalseries_isf
file:sphericalseries_isf.m: calculates something for given argument

*** Octave definition                                              :internal:

#+BEGIN_SRC octave :tangle sphericalseries_isf.m
<<sphericalseries_isf doc[:results ascii :post octave comment(s=*this*)]()>>
<<copyright>>
function F_CABF = sphericalseries_isf(f_OCF, Y_OAB, perm)

% sphericalseries_isf - performs inverse spherical Fourier transform
%
% F_CABF = sphericalseries_isf(f_OCF, Y_OAB, perm)
% 
% INPUTS
% f_OCF
% Y_OAB
% perm - permutation matrix
%
% OUTPUTS
% F_CABF
%
% DESCRIPTIOn
% If the number of input arguments is less than 3, the permutation matrix perm is emty, so no
% permutation is done.
%

  if nargin < 3
    perm = [];
  end
  
  % Summanden der ISFT berechnet:
  F_OCABF = sphericalseries_isfs(f_OCF, Y_OAB);

  % über Summenindex o addiert; verbleibende Dimension O = 1
  % anschließend wegschieben (d.h. F_CBAF1 entsteht; squeeze geht
  % nicht, da andere Dimensionen mit 1 mitwegfallen würden)
  F_CABF = shiftdim(sum(F_OCABF, 1), 1);

  % falls gesetzt, permutieren
  if ~isempty(perm)
    F_CABF = permute(F_CABF, perm);
  end

#+END_SRC

*** Interface test                                                 :internal:

#+BEGIN_SRC octave
f_OCF = ones(1, 1, 6);
Y_OAB = ones(4, 1, 1);
F_CABF = sphericalseries_isf(f_OCF, Y_OAB);
ans = size(F_CABF);
#+END_SRC

#+RESULTS:
| 1 | 1 | 1 | 6 |

*** Documenation                                                     :ignore:

    #+name: sphericalseries_isf doc
    #+BEGIN_SRC org
    ,*** Syntax

    ,*** Description

    ,*** Input Arguments

    ,*** Return Values

    ,*** Examples

    ,*** Tips

    ,*** Alternatives

    ,*** See Also
    #+END_SRC

    #+call: sphericalseries_isf doc[:output html]()


** sphericalseries_sfc
file:sphericalseries_sfc.m: returns the coefficients of spherical Fourier transform 

*** Octave definition                                              :internal:

#+BEGIN_SRC octave :tangle sphericalseries_sfc.m
<<sphericalseries_sfc doc[:results ascii :post octave comment(s=*this*)]()>>
<<copyright>>
function C_OCFD = sphericalseries_sfc(A_OFD, B_OFD, r_C, R_src, k_F)

  % Speicher klarmachen
  O = size(A_OFD, 1);
  F = size(A_OFD, 2);
  D = size(A_OFD, 3);
  C = length(r_C);
  C_OCFD = zeros(O, C, F, D);
  
  % Wertebereich aufteilen
  ind_ext  = find(r_C <= R_src); % exterior case
  ind_int  = find(r_C >  R_src); % interior case

  % entsprechende spezielle Funktionen berechnen
  N_order = sqrt(O) - 1;
  if ~isempty(ind_ext)
    j_OCF = sphericalbessel(N_order, r_C(ind_ext).'*k_F);
  end
  if ~isempty(ind_int)
    h_OCF = sphericalhankel(N_order, r_C(ind_int).'*k_F);
  end
  
  % sph. fourier coeff. berechnet
  for d = 1:D
    for f = 1:F
      for c = 1:length(ind_ext)
        C_OCFD(:,ind_ext(c), f, d) = A_OFD(:,f,d) .* j_OCF(:,c,f);
      end
      for c = 1:length(ind_int)
        C_OCFD(:,ind_int(c), f, d) = B_OFD(:,f,d) .* h_OCF(:,c,f);
      end
    end
  end

#+END_SRC

*** Interface test                                                 :internal:

*** Documenation                                                     :ignore:

#+name: sphericalseries_sfc doc
#+BEGIN_SRC org
,*** Syntax

: C_OCFD = sphericalseries_sfc(A_OFD, B_OFD, r_C, R_src, k_F)


,*** Description

,*** Input Arguments
- A_OFD - matrix of HOA coefficients
- B_OFD - matrix of HOA coefficients
- r_C - radius ???
- R_src - source radius
- k_F - vector of a wave number values for a given frequency range

,*** Return Values
- C_OCFD - multi-dimensional matrix of the spherical FT coefficients

,*** Examples

,*** Tips

,*** Alternatives

,*** See Also

sphericalbessel, sphericalhankel
#+END_SRC

#+call: sphericalseries_sfc doc[:output html]()

* Higher Order Ambisonics
** Sphericalseries_hoa

file:sphericalseries_hoa.m: returns result of HOA series

*** Octave definition                                              :internal:

#+BEGIN_SRC octave :tangle sphericalseries_hoa.m
<<sphericalseries_hoa doc[:results ascii :post octave comment(s=*this*)]()>>
<<copyright>>
function p_CABF = sphericalseries_hoa(C_OF, F_OCABF, D_OF, G_OCABF)

  if length(size(F_OCABF)) < 3
    error('Function basis needs at least 3 dimensions.');
  end
  
  % berechne Ergebnis der Reihenentwicklung mit Koeffizienten C mit
  % Funktionsbasis F:
  if ~isempty(F_OCABF)
    p_CABF = sphericalseries(C_OF, F_OCABF);
  else
    p_CABF = [];
  end
  
  % falls zwei Koeffzi. und Basen übergeben, weitere Berechnung:
  if nargin == 4
    
    if ~isempty(G_OCABF)
      q_CABF = sphericalseries(D_OF, G_OCABF);
    else
      q_CABF = [];
    end

    % concatiniere 8) Ergebnis: 
    p_CABF = [p_CABF; q_CABF];
  end
  
function p_CABF = sphericalseries(C_OF, F_OCABF)
% bestimme Größe der Eingangsmatrizen 
  C = size(F_OCABF, 2);
  A = size(F_OCABF, 3);
  B = size(F_OCABF, 4);
  F = size(F_OCABF, 5);
  p_CABF = zeros(C, A, B, F);
  for f = 1:F
    for c = 1:C
      for a= 1:A
        for b = 1:B
          p_CABF(c, a, b, f) = C_OF(:,f).' *  F_OCABF(: ,c, a, b, f);
        end
      end
    end
  end

#+END_SRC
*** Interface test                                                 :internal:

#+BEGIN_SRC octave
C_OF = ones(4, 4);
F_OCABF = ones(4, 1, 1, 1, 4);
p_CABF = sphericalseries_hoa(C_OF, F_OCABF);
ans = size(p_CABF);
#+END_SRC

#+RESULTS:
| 1 | 1 | 1 | 4 |

*** Documenation                                                     :ignore:

#+name: sphericalseries_hoa doc
#+BEGIN_SRC org
,*** Syntax

: p_CABF = sphericalseries_hoa(C_OF, F_OCABF, D_OF, G_OCABF)

,*** Description

Returns result of HOA series with coefficients C and D and basis functions F and G. 
The second pair (D and G) is optional.
The matrix of basis function should have at least 3 dimensions.

,*** Input Arguments

- C_OF :: ???????
- F_OCABF :: basis function values matrix
- D_OF :: ??????
- G_OCABF :: basis function values matrix

,*** Return Values

,*** Examples

,*** Tips

,*** Alternatives

,*** See Also
    #+END_SRC

    #+call: sphericalseries_hoa doc[:output html]()

** Sphericalseries_hoa_plane

file:sphericalseries_hoa_plane.m: calculates plane wave coefficients $A$ for a HOA representation.

*** Octave definition                                              :internal:

#+BEGIN_SRC octave :tangle sphericalseries_hoa_plane.m
<<sphericalseries_hoa_plane doc[:results ascii :post octave comment(s=*this*)]()>>
<<copyright>>

function A_OFD = sphericalseries_hoa_plane(N_order, theta_D, phi_D, ...
                                           S_norm, S_type, F, ...
                                           psi_D);
  D = length(theta_D);
  if nargin < 7
    psi_D = ones(1, D);
  end
  
  % Vorfaktor ebene Welle
  N_O = sphericalnormalisation(N_order, 'planewave');
  
  % Modenmatrix für alle Einfallsrichtungen
  Psi_OD = sphericalmodematrix(N_order, theta_D, phi_D, ...
                               S_norm, S_type);

  % return: Die Koeffzi. der ebenen Welle sind frequenzunabhängig, nur
  % rein formal wird Dimension F mit aufgefüllt.
  A_OFD = zeros((N_order+1)^2, F, D);
  for f = 1:F
    for d = 1:D
      A_OFD(:,f,d) = psi_D(d) * (N_O .* Psi_OD(:,d));
    end
  end
#+END_SRC

*** Interface test                                                 :internal:

#+BEGIN_SRC octave
N_order = 2;
theta_D = pi;
phi_D = pi;
S_norm = 'N3D';
S_type = 'complex';
F = 1;
psi_D = 1;
A_OFD = sphericalseries_hoa_plane(N_order, theta_D, phi_D, S_norm, S_type, F, psi_D);
ans = size(A_OFD);
#+END_SRC

#+RESULTS:
| 9 | 1 |

*** Documenation                                                     :ignore:

#+name: sphericalseries_hoa_plane doc
#+BEGIN_SRC org
,*** Syntax
: A_OFD = sphericalseries_hoa_plane(N_order, theta_D, phi_D, S_norm, S_type, F, psi_D)

,*** Description
calculates plane wave coefficients $A$ for a HOA representation.

,*** Input Arguments
- N_order :: Ambisonics order
- theta_D ::  vector representing the calculation range of inclination theta
- phi_D :: vector representing the calculation range of azimuth phi
- S_norm :: string with type of normalization: 
            | 'norm'                | fully normalized;                     |
            | 'N3D'                 | normalized;                           |
            | 'sch0' or 'SN3D'      | seminormalazed                        |
            | 'sch1'                | Schmidt-Semi-normalized (Matlab)      |
            | 'sconv'               | norm. over all spherical convolutions |
            | 'planewave_impinging' | norm. for plane waves                 |
- S_type :: type of the spherical harmonic: 'real', 'real_signed', 'real_unsigned'  or 'complex'
- F :: number of frequency bins (having all the same value)
- psi_D :: weights for D input direction (optional argument)

,*** Return Values
- A_OFD :: matrix of HOA coefficients

,*** Examples

,*** Tips

,*** Alternatives

,*** See Also
sphericalnormalisation, sphericalmodematrix
#+END_SRC

#+call: sphericalseries_hoa_plane doc[:output html]()

#+name: spherical series hoa planewave test
#+BEGIN_SRC octave
% Rasta
% -------------------------------------------------------------------

% conus
if 0
  R_max = 1.5;
  C = 50; r_C = linspace(0, R_max, C);
  A = 1;  theta_A = linspace(pi/2, pi/2, A);
  B = 50; phi_B = linspace(0, 2*pi,    B);
  gg_CAB = vectorgrid(r_C, theta_A, phi_B, 'spherical');
end

% sphere
if 1
  R_max = .15;
  C = 1; r_C = linspace(R_max, R_max, C);
  A = 30;  theta_A = linspace(0, pi, A);
  B = 40; phi_B = linspace(0, 2*pi,  B);
  gg_CAB = vectorgrid(r_C, theta_A, phi_B, 'spherical');
end

% Spherical stuff
% -------------------------------------------------------------------
N_order = 7;
F = 4;
f_F = linspace(100, 1000, F); % Frequenzen
k_F = -2*pi*f_F/342; % Wellenzahl

% ebene Welle
% -------------------------------------------------------------------
Theta_i = pi/2;
Phi_i = pi/2;
S_norm = 'norm';
S_type = 'complex';
A_OF = sphericalseries_hoa_plane(N_order, Theta_i, Phi_i, ...
                                 S_norm, S_type, F);

% Sphärische-Fouriertransformations-Coeffizienten (sfc)
% -------------------------------------------------------------------
C_OCF = sphericalseries_sfc(A_OF, [], r_C, inf, k_F);

% inverse sphärische Fouriertransformation (isf)
% -------------------------------------------------------------------

% Basisfunktion
Y_OAB = sphericalharmonic(N_order, theta_A, phi_B, S_norm, S_type);

% ISF im Frequenzbereich
P_CABF = sphericalseries_isf(C_OCF, Y_OAB);

% malen
% -------------------------------------------------------------------
if 1
  for f = 1:F
    figure(f);
    surface(gg_CAB, squeeze(abs(real(P_CABF(:,:,:,f)))));
    axis('equal');
    grid('on');
    view([30 40]);
  end
end

#+END_SRC

#+RESULTS: spherical series hoa planewave test
: 0

** sphericalseries_hoa_spherical
** sphericalseries_hoa_basis

file:sphericalseries_hoa_basis.m: returns spherical basis functions R = j_n Y and S = h_n Y

*** Octave definition                                              :internal:

#+BEGIN_SRC octave :tangle sphericalseries_hoa_basis.m
<<sphericalseries_hoa_basis doc[:results ascii :post octave comment(s=*this*)]()>>
<<copyright>>

function [R_OCABF, S_OCABF] = sphericalseries_hoa_basis(N_order, R_src, ...
                                               vg_CAB, k_F, ...
                                               S_norm, S_type)

  if strcmp(type(vg_CAB), 'spherical')
    
    [r_C, theta_A, phi_B] = grid(vg_CAB);
    
    ind_ext  = find(r_C <= R_src); % exterior case
    ind_int  = find(r_C >  R_src); % interior case
    
    % Basisfunktionen als Summanden der inversen
    % sph. Fouriertransformation mit den Funktionen j_n und h_n
    % berechnet:
    Y_OAB = sphericalharmonic(N_order, theta_A, phi_B, S_norm, S_type);

    if ~isempty(ind_ext)
      j_OCF = sphericalbessel(N_order, r_C(ind_ext).'*k_F);
      R_OCABF = sphericalseries_isfs(j_OCF, Y_OAB);
    else
      R_OCABF = [];
    end

    if ~isempty(ind_int)
      h_OCF = sphericalhankel(N_order, r_C(ind_int).'*k_F);
      S_OCABF = sphericalseries_isfs(h_OCF, Y_OAB);
    else
      S_OCABF = [];
    end
  else 
    error('Vectorgrid need to be spherical (at least in a way...).');
  end
#+END_SRC

#+RESULTS:

*** Interface test                                                 :internal:
#+BEGIN_SRC octave
N_order = 1;
R_src = 1;
A = 20; B = 30; C = 40;
x_A = linspace(-3, 3, A);
y_B = linspace(-2, 2, B);
z_C = linspace(-4, 4, C);
k_F = 1;
S_norm = 'N3D';
S_type = 'complex';
vg_ABC = vectorgrid(x_A, y_B, z_C, 'spherical');
[R_OCABF, S_OCABF] = sphericalseries_hoa_basis(N_order, R_src, ...
					       vg_ABC, k_F, ...
					       S_norm, S_type);
ans = size(R_OCABF);
#+END_SRC

#+RESULTS:
| 4 | 13 | 30 | 40 |

*** Documenation                                                     :ignore:
#+name: sphericalseries_hoa_basis doc
#+BEGIN_SRC org
,*** Syntax

,*** Description
: [R_OCABF, S_OCABF] = sphericalseries_hoa_basis(N_order, R_src, ...
:                                            vg_CAB, k_F, ...
:                                            S_norm, S_type)
 
returns spherical basis functions R = j_n Y and S = h_n Y
    
,*** Input Arguments

,*** Return Values

,*** Examples

,*** Tips

,*** Alternatives

,*** See Also
#+END_SRC

#+call: sphericalseries_hoa_basis doc[:output html]()

** sphericalseries_sfc
* Examples
** Plane wave

#+name: plane wave grid
#+BEGIN_SRC octave :tangle sfs_plane_test.m :results output :session plane
R_max = 1.4;
C = 40; r_C     = linspace(0, R_max, C);
A = 1;   theta_A = pi/2;
B = 40; phi_B   = linspace(0, 2*pi,    B);
gg_CAB = vectorgrid(r_C, theta_A, phi_B, 'spherical');
#+END_SRC

#+RESULTS: plane wave grid


We define a *plane wave* with frequency and direction of the plane wave.
#+name: plane wave params
#+BEGIN_SRC octave :tangle sfs_plane_test.m  :results output :session plane
C_snd = 342;                       % m/s
F     = 1;                         % 
F_max = 500;                       % Hz
F_min = 1;                         % Hz
f_F   = linspace(F_min, F_max, F); % frequencies
k_F   = -2*pi*f_F/C_snd;           % wavenumber
Theta_src = pi/2;
Phi_src   = pi/2;
R_src     = 1.2;
vM_src    = vector(R_src, Theta_src, Phi_src, 'spherical');
#+END_SRC

#+RESULTS: plane wave params

With these parameters we can describe a plane wave as follows:
#+name: plane wave defn
#+BEGIN_SRC octave  :tangle sfs_plane_test.m :results output :session plane
vm_E = vector(gg_CAB); % a grid in space
vk_F = scale(k_F, normalize(vM_src)); % wave number vector
P_real_EF = planewave(vm_E, vk_F); % pressure of plane wave
#+END_SRC

#+RESULTS: plane wave defn

Now we define the HOA approximation
#+name: plane wave hoa
#+BEGIN_SRC octave  :tangle sfs_plane_test.m :results output :session plane
S_norm = 'norm';
S_type = 'real';
N_order = 10;
Psi_src_O = sphericalmodematrix(N_order, Theta_src, Phi_src, S_norm, S_type);
N_pln_O = sphericalnormalisation(N_order, 'planewave');
A_pln_O = N_pln_O .* Psi_src_O;
k_rtp_F = get(vk_F, 'spherical');
C_pln_OC = sphericalseries_sfc(A_pln_O, [], r_C, inf, k_rtp_F(1));
Y_OAB = sphericalharmonic(N_order, theta_A, phi_B, S_norm, S_type);
P_CAB = sphericalseries_isf(C_pln_OC, Y_OAB);
#+END_SRC

#+RESULTS: plane wave hoa

The output results in
#+name: plane wave hoa plot
#+BEGIN_SRC octave  :tangle sfs_plane_test.m :results output :session plane :var S_file = "img/sfs_planewave.png"
v_view = [30 50];
%c_map = colormap(badcolormap(256));
figure(1); clf;
surface(gg_CAB, real(P_CAB));
c_map = colormap('hot');
c_minmax = max(max(max((abs(real(P_CAB)))))) * [-1 1];
caxis(c_minmax);
colormap(c_map);
axis('equal');
grid('on');
view(v_view);
title('\Re p');
xlabel('x (m)');
ylabel('y (m)');
zlabel('z (m)');
saveas(1, S_file);
#+END_SRC

#+RESULTS: plane wave hoa plot

#+name: HOA approximation of a plane wave.
#+caption: HOA approximation of a plane wave.
#+attr_org: :width 300
[[file:img/sfs_planewave.png]]
